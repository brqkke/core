/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  /** Available currencies are those exclusively supported by Bity. */
  '/currencies': {
    get: operations['get_currencies'];
  };
  /** Obtain information about a specified currency. */
  '/currencies/{currency_code}': {
    get: operations['get_currency_by_code'];
  };
  '/orders': {
    /**
     * Get a list of previously placed orders. Depending on the authentication
     * method used different orders will be returned.
     *
     * When the `bity_account_oauth` or `bity_account_client_oauth` security
     * schemes are used, which orders are visible depends on the scope of the
     * access token.
     */
    get: operations['list_orders'];
    /**
     * It is possible to specify amount in the input or output in which case
     * the corresponding input or output amount will be computed.
     *
     * The input or output amount can be estimated beforehand using the
     * dedicated endpoint, see "Estimate the amount of an order".
     *
     * The input object must in principle contain the IBAN or crypto address
     * which will be used to pay the order. In some cases, this is optional.
     * See "Estimate the amount of an order" to figure out if this information
     * can be omitted or not. Omitting the information increases the number of
     * situations were we can be required to cancel an order uppon
     * reception of the funds. To ensure a reliable execution of your order,
     * the crypto address or IBAN must be provided and the paiment must be
     * made from the provided object.
     */
    post: operations['place_order'];
  };
  /**
   * Gets an accurate estimation for the output amount given an input amount
   * and vice-versa. It however does not take into account all the limitations
   * (such as currently consumed quota) that are enforced when an order is
   * placed. As such, obtaining an estimation does not guarantee that the
   * corresponding order can be placed.
   *
   * The response also contains the minimum amount allowed for placing an
   * order with this pair. When the amount in the request is too small, an
   * estimation for the minimum amount is performed instead.
   */
  '/orders/estimate': {
    /**
     * The endpoint is similar to the endpoints allowing an order to be placed.
     * However, only the currencies and the input or output amount are
     * specified in the request.
     *
     * ### Estimate the output amount corresponding to an input amount
     *
     * To estimate the output amount simply place the `amount` in the `input`.
     *
     * ### Estimate the input amount corresponding to an output amount
     *
     * To estimate the input amount simply place the `amount` in the `output`.
     */
    post: operations['estimate_order_amount'];
  };
  '/orders/estimate/multiple': {
    /** This endpoint is equivalent to `/orders/estimate` except that several estimations can be performed in a single request. */
    post: operations['estimate_order_amount_multiple'];
  };
  '/orders/{order_uuid}': {
    /**
     * Please note the following:
     *
     * - If the amount paid is not exactly the input amount, we can be
     *   required to cancel the order, or the output amount will be adjusted
     *   and extra fees could be charged.
     * - If it is sent in multiple transactions, we can be required to cancel
     *   the order and extra processing fees could be charged.
     *
     * ### Minimal details
     *
     * When the request does not include sufficient credentials, only minimal
     * information is returned. If you are unexpectedly receiving only minimal
     * details, please double check which security scheme you are using and
     * used to place the order. When no security scheme is used, please make
     * sure you are making all the requests to the correct URLs and that
     * cookies are accepted and handled according to RFC 6265. Most user
     * agents handle that for you but cookies must not be disabled and you may
     * have to request the user-agent to include credentials in the request.
     *
     * The full information is returned when one of the following is true:
     *
     * - No security scheme is used and the order was placed while
     *   unauthenticated, in the same session.
     * - The `bity_account_oauth` or `bity_account_oauth_client` security
     *   scheme are used, the scope includes
     *   `https://auth.bity.com/scopes/exchange.place` or
     *   `https://auth.bity.com/scopes/exchange.history`, and the OAuth client
     *   is the client having placed the order.
     * - The `bity_account_oauth` or `bity_account_oauth_client` security
     *   scheme are used and the scope includes
     *   `https://auth.bity.com/scopes/exchange.audit`.
     * - The `client_oauth` security scheme is used and the OAuth client is
     *   the client having placed the order.
     *
     * ### Output address signature
     *
     * When the customer is not authenticated or has not gone through the KYC
     * process, crypto-to-crypto and fiat-to-crypto orders require the
     * signature of a message by the output address for the order to become
     * executable. When such a signature is required "message_to_sign" is
     * included in the response. The price will not be fixed and the payment
     * details will not be provided before the signature of the message is
     * submitted.
     *
     * ### Input and output objects
     *
     * The input type and output type can be one of "crypto_address" or
     * "bank_account".
     *
     * - In case it is "crypto_address" the object additionally contains
     *   "crypto_address".
     * - In case it is "bank_account" the object additionally contains "iban".
     *
     * Whenever the input object contains iban or crypto_address, the input
     * must be paid from the corresponding object. If this is not the case, we
     * can be required to cancel the order and perform a refund uppon
     * reception of the funds and extra fees can be charged.
     *
     * ### Payment details
     *
     * This object describes how to pay the input amount.
     *
     * There are two different possible types of payment details:
     * `"crypto_address"` and `"bank_account"`. Both types are described
     * bellow. The amount and the associated currency is found in the input
     * object.
     *
     * #### Crypto address
     *
     * When the payment must be made to a crypto address, the `type` is
     * `"crypto_address"` and the address to use as a destination address
     * is found in the `"crypto_address"` attribute.
     *
     * #### Bank account
     *
     * When the payment must be made to a bank account, the type is
     * `"bank_account"`.
     *
     * In most cases the banks involved in sending, transmitting and receiving
     * the payment will require the IBAN, SWIFT code and the bank account
     * owner name and address to process the payment. This is reflected by the
     * information provided in the response:
     *
     * - `"iban"`: The IBAN to which the payment must be made.
     * - `"owner"`: An object containing information about the owner of the
     *   bank account. It can contain the following properties: "name",
     *   "address", "address_complement", "zip", "city", "state", "country".
     *   The country is formatted as a two-letter country code.
     * - `"swift_bic"` The SWIFT code (also known as BIC) of the bank account
     *   at which the bank account is located.
     *
     * ### Amounts
     *
     * When `timestamp_price_guaranteed` is not present or has elapsed, the
     * amounts (input, output and price breakdown) are an estimation of the
     * amounts that would have been used should the order have been executed
     * at the time the order details were retrieved.
     *
     * When `timestamp_price_guaranteed` is present and has not elapsed, the
     * amounts correspond to the amounts that will be used provided that the
     * exact input amount is received before `timestamp_price_guaranteed`
     * elapses.
     */
    get: operations['get_order_details'];
  };
  '/orders/{order_uuid}/cancel': {
    /**
     * Attempt to cancel an order.
     *
     * If a payment is received after the order has been cancelled, Bity is
     * free to choose what to do at its own discretion. Bity will generally
     * attempt to perform a refund to the same crypto-address or IBAN having
     * performed the payment. Various unpredictable fees may apply. It is very
     * highly recommended to not cancel orders for which a payment has already
     * been sent.
     *
     * This functionality is meant for the customer to cancel orders for which
     * no payment has been made and will be made. In particular, it is not
     * meant to cancel orders for which a payment has already been made or
     * will be made at a later time, and will result in an unpredictable
     * outcome if used in such situation.
     */
    post: operations['cancel_order'];
  };
  '/orders/{order_uuid}/duplicate': {
    /**
     * This endpoint places a new order with the same amount, same input
     * object, same ouput object and same payment details as an already
     * executed one.
     *
     * It is only possible to duplicate orders of which the full order details
     * are accessible.
     */
    post: operations['duplicate_order'];
  };
  '/orders/{order_uuid}/signature': {
    /**
     * Submit the signature of the message provided in the order details.
     *
     * The body of the request must contain the signature of the message.
     * The message to sign is located in the `body` property of the
     * `message_to_sign` object of the order details.
     *
     * Once the signature is verified to be correct (204 response), the
     * order becomes executable and the order details will contain the
     * `payment_details` object which provides the information to use to pay
     * the order.
     *
     * Do not build the URL of this endpoint but instead use the value of
     * `signature_submission_url` included along the message to be signed in
     * the order details.
     */
    post: operations['sign_proof_of_ownership_message'];
  };
  /** Available currency pairs are those exclusively supported by Bity. */
  '/pairs': {
    /** Gets a list of all the currency pairs that can be traded through the Bity platform. */
    get: operations['list_currency_pairs'];
  };
}

export interface components {
  schemas: {
    AmountEstimation: {
      input: components['schemas']['AmountEstimationInput'];
      output: components['schemas']['AmountEstimationOutput'];
      price_breakdown: components['schemas']['PriceBreakdown'];
    };
    /**
     * @example {
     *   "amount": "0.1",
     *   "currency": "BTC",
     *   "minimum_amount": "0.01"
     * }
     */
    AmountEstimationInput: {
      amount?: string;
      currency: components['schemas']['CurrencyCode'];
      minimum_amount?: string;
      /** @description When true, indicates that it is not required to provide information about the object which is going to pay the order. In order to not provide information about the input object, do not include `bic_swift`, `crypto_address`, `iban`, `owner` and `type` in the input object. */
      object_information_optional?: boolean;
    };
    /**
     * @example {
     *   "amount": "0.1",
     *   "currency": "BTC",
     *   "minimum_amount": "0.01"
     * }
     */
    AmountEstimationOutput: {
      amount?: string;
      currency: components['schemas']['CurrencyCode'];
      minimum_amount?: string;
    };
    AmountEstimationRequest: {
      input: components['schemas']['AmountEstimationRequestInputOutput'];
      output: components['schemas']['AmountEstimationRequestInputOutput'];
      partner_fee?: components['schemas']['PartnerFee'];
    };
    AmountEstimationRequestInputOutput: {
      amount?: string;
      currency: components['schemas']['CurrencyCode'];
    };
    /** @description An arbitrary integer provided by the API client. The property is shown in the order details and in the reporting API. */
    ClientValue: number;
    /** @example BTC */
    CurrencyCode: string;
    /**
     * @example {
     *   "code": "ETH",
     *   "max_digits_in_decimal_part": 18,
     *   "tags": [
     *     "crypto",
     *     "ethereum"
     *   ]
     * }
     */
    CurrencyDetails: {
      code: components['schemas']['CurrencyCode'];
      /** @description The maximum number of digits in the fractional part of values represented with decimal numbers. */
      max_digits_in_decimal_part?: number;
      tags: components['schemas']['CurrencyTag'][];
    };
    /**
     * @example {
     *   "enabled": true,
     *   "input": "BTC",
     *   "output": "CHF"
     * }
     */
    CurrencyPair: {
      enabled: boolean;
      input: components['schemas']['CurrencyCode'];
      output: components['schemas']['CurrencyCode'];
    };
    /** @enum {string} */
    CurrencyTag: 'crypto' | 'erc20' | 'ethereum' | 'fiat';
    /**
     * @description A message to be signed. The signature must be sent in the body of a
     * POST request to the URL specified by "signature_submission_url". This
     * endpoint returns a 204 status code uppon submission of a valid
     * signature.
     *
     * The message must be encoded as UTF-8 and the resulting sequence of
     * bytes signed. Make sure to keep the message intact, including all white
     * spaces. Use "eth_sign" with Ethereum addresses and "signmessage" with
     * Bitcoin addresses. Keep the signature in the format provided by those
     * calls (at the time of writing it is an hexadecimal string for Ethereum
     * and base64 string for Bitcoin).
     */
    MessageToSign: {
      body: string;
      signature_submission_url: string;
    };
    /**
     * @example {
     *   "id": "209a6210-4ea3-43e4-ba92-73aac60fb10c",
     *   "input": {
     *     "amount": "0.5",
     *     "crypto_address": "0x24305d091f79ee490a34de080b0db5773be5bef4",
     *     "currency": "ETH",
     *     "type": "crypto_address"
     *   },
     *   "legacy_status": "CANC",
     *   "output": {
     *     "amount": "104.95",
     *     "bic_swift": "BCNNCH22",
     *     "currency": "CHF",
     *     "iban": "CH3600000000000000000",
     *     "owner": {
     *       "address": "Rue des Fahrys 2",
     *       "city": "Neuchatel",
     *       "country": "CH",
     *       "name": "John Doe"
     *     },
     *     "type": "bank_account"
     *   },
     *   "payment_details": {
     *     "crypto_address": "0xf35074bbd0a9aee46f4ea137971feec024ab7048",
     *     "type": "crypto_address"
     *   },
     *   "timestamp_cancelled": "2019-01-25T01:06:11.632Z",
     *   "timestamp_created": "2019-01-24T13:14:07.368Z"
     * }
     */
    Order: {
      client_value?: components['schemas']['ClientValue'];
      /** @description Unique identifier of the order. */
      id: string;
      input: components['schemas']['OrderInputOutput'];
      message_to_sign?: components['schemas']['MessageToSign'];
      output: components['schemas']['OrderInputOutput'];
      payment_details?: {
        account_number?: string;
        bank_address?: string;
        bank_code?: string;
        /** @description Only valid if `type` is `crypto_address`. */
        crypto_address?: string;
        iban?: string;
        /** @description Do not use. Use `recipient_name` and `recipient_postal_address` instead. */
        recipient?: string;
        /** @description Name of the recipient of the payment. */
        recipient_name?: string;
        /** @description Postal address of the recipient of the payment. */
        recipient_postal_address?: string[];
        /** @description The  reference (also known as communication) that must be included in the payment. */
        reference?: string;
        swift_bic?: string;
        type?: components['schemas']['OrderInputOutputType'];
      };
      price_breakdown: components['schemas']['PriceBreakdown'];
      /**
       * Format: date-time
       * @description Date and time at which the order became executable and at which the payment information was made available.
       */
      timestamp_awaiting_payment_since?: string;
      /**
       * Format: date-time
       * @description Date and time at which the order was cancelled.
       */
      timestamp_cancelled?: string;
      /**
       * Format: date-time
       * @description Date and time at which the client submitted the initial information regarding this order.
       */
      timestamp_created: string;
      /**
       * Format: date-time
       * @description Date and time at which the output amount was sent.
       */
      timestamp_executed?: string;
      /**
       * Format: date-time
       * @description Date and time at which the input amount is confirmed to have been received.
       */
      timestamp_payment_received?: string;
      /**
       * Format: date-time
       * @description When present, the price is locked until the current time exceeds
       * that particular timestamp. If the payment of the appropriate input
       * amount is received before the indicated time, then the currently
       * shown output amount will be sent. If the payment is received at a
       * later time, execution of the order will use the market price
       * instead.
       *
       * When absent, indicates that the price has not been locked yet.
       */
      timestamp_price_guaranteed?: string;
    };
    /**
     * @example {
     *   "input": {
     *     "amount": "0.5",
     *     "crypto_address": "0x24305d091f79ee490a34de080b0db5773be5bef4",
     *     "currency": "ETH",
     *     "type": "crypto_address"
     *   },
     *   "output": {
     *     "amount": "104.95",
     *     "bic_swift": "XXXXCHXXXXX",
     *     "currency": "CHF",
     *     "iban": "CH3600000000000000000",
     *     "type": "bank_account"
     *   }
     * }
     */
    OrderInputOutput: {
      /** @description The input and output amounts are all inclusive. They include costs and fees. */
      amount?: string;
      /** @description Only valid if `type` is `bank_account`. */
      bic_swift?: string;
      /** @description Only valid if `type` is `crypto_address`. */
      crypto_address?: string;
      currency: components['schemas']['CurrencyCode'];
      /** @description Only valid if `type` is `bank_account`. */
      iban?: string;
      /** @description Only valid if `type` is `bank_account`. */
      owner?: {
        address?: string;
        address_complement?: string;
        city?: string;
        /** @description Must contain the two-letter country code (ISO 3166-1 alpha-2). */
        country?: string;
        name?: string;
        state?: string;
        zip?: string;
      };
      /**
       * @description Only valid if `type` is `bank_account`. It can only be present as
       * output.
       *
       * The length and the set of supported characters varies depending on
       * the banks and networks involved. To avoid producing the
       * "invalid_bank_account_reference" error, keep the reference short
       * (32 characters or less is recommended) and use only simple
       * characters (using only characters in a-z, A-Z, 0-9 and space is
       * recommended).
       */
      reference?: string;
      type?: components['schemas']['OrderInputOutputType'];
    };
    /** @enum {string} */
    OrderInputOutputType: 'crypto_address' | 'bank_account';
    /**
     * @description Minimal information of a previously placed order. This information can be retrieved without authentication.
     * @example {
     *   "id": "f4e05c68-8a70-4678-b97c-ea30dc0daaa3",
     *   "timestamp_awaiting_payment_since": "2019-02-01T10:02:00.000Z",
     *   "timestamp_created": "2019-02-01T10:00:00.000Z",
     *   "timestamp_price_guaranteed": "2020-02-01T10:12:00.000Z"
     * }
     */
    OrderMinimal: {
      /** @description Unique identifier of the order. */
      id: string;
      /**
       * Format: date-time
       * @description Date and time at which the order became executable and at which the payment information was made available.
       */
      timestamp_awaiting_payment_since?: string;
      /**
       * Format: date-time
       * @description Date and time at which the order was cancelled.
       */
      timestamp_cancelled?: string;
      /**
       * Format: date-time
       * @description Date and time at which the client submitted the initial information regarding this order.
       */
      timestamp_created: string;
      /**
       * Format: date-time
       * @description Date and time at which the output amount was sent.
       */
      timestamp_executed?: string;
      /**
       * Format: date-time
       * @description Date and time at which the input amount is confirmed to have been received.
       */
      timestamp_payment_received?: string;
      /**
       * Format: date-time
       * @description When present, the price is locked until the current time exceeds
       * that particular timestamp. If the payment of the appropriate input
       * amount is received before the indicated time, then the currently
       * shown output amount will be sent. If the payment is received at a
       * later time, execution of the order will use the market price
       * instead.
       *
       * When absent, indicates that the price has not been locked yet.
       */
      timestamp_price_guaranteed?: string;
    };
    Pagination: {
      /** @description Current page number */
      current: number;
      /** @description Page number of the first page */
      first?: number;
      /** @description Page number of the last page */
      last?: number;
    };
    /** @description -> An additional fee perceived on behalf of the partner placing the order, expressed as a factor of the amount received from the customer. */
    PartnerFee: {
      factor: Partial<number> & Partial<string>;
    };
    PriceBreakdown: {
      /** @description The customer trading fee applied to this order. */
      customer_trading_fee?: {
        amount: string;
        currency: components['schemas']['CurrencyCode'];
      };
      /** @description The non-verified fee applied to this order. */
      'non-verified_fee'?: {
        amount: string;
        currency: components['schemas']['CurrencyCode'];
      };
      /**
       * @description Execution cost of the output transaction. Includes crypto
       * transaction fees, bank transaction fees, etc.
       */
      output_transaction_cost?: {
        amount: string;
        currency: components['schemas']['CurrencyCode'];
      };
      /** @description -> Additional fee perceived on behalf of the partner having placed the order. */
      partner_fee?: {
        amount: string;
        currency: components['schemas']['CurrencyCode'];
      };
    };
  };
  responses: {
    /** Rate-limited (request ignored) */
    RateLimited: unknown;
  };
  headers: {
    /** When applicable, links to the first, previous, next and last pages, formatted as per RFC 5988. */
    Link?: string;
  };
}

export interface operations {
  get_currencies: {
    parameters: {
      query: {
        /** Comma-separated list of tags. Currencies that contain all tags will be filtered. */
        tags?: components['schemas']['CurrencyTag'][];
      };
    };
    responses: {
      /** Successful operation */
      200: {
        content: {
          'application/json': {
            currencies: components['schemas']['CurrencyDetails'][];
          };
        };
      };
      429: components['responses']['RateLimited'];
    };
  };
  get_currency_by_code: {
    parameters: {
      path: {
        /** Currency code identifying the currency about which to return information. */
        currency_code: components['schemas']['CurrencyCode'];
      };
    };
    responses: {
      /** Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['CurrencyDetails'];
        };
      };
      /** Currency not found or unsupported */
      404: unknown;
      429: components['responses']['RateLimited'];
    };
  };
  /**
   * Get a list of previously placed orders. Depending on the authentication
   * method used different orders will be returned.
   *
   * When the `bity_account_oauth` or `bity_account_client_oauth` security
   * schemes are used, which orders are visible depends on the scope of the
   * access token.
   */
  list_orders: {
    parameters: {
      query: {
        /** Number of the page to retrieve, defaults to the first page (1). See also the `Link` header in the 200 response. */
        page?: number;
        /** Number of orders to include in a page. When not specified, 100. */
        page_size?: number;
      };
    };
    responses: {
      /** Successful operation. */
      200: {
        headers: {};
        content: {
          'application/json': {
            orders: components['schemas']['Order'][];
            pagination?: components['schemas']['Pagination'];
          };
        };
      };
      429: components['responses']['RateLimited'];
    };
  };
  /**
   * It is possible to specify amount in the input or output in which case
   * the corresponding input or output amount will be computed.
   *
   * The input or output amount can be estimated beforehand using the
   * dedicated endpoint, see "Estimate the amount of an order".
   *
   * The input object must in principle contain the IBAN or crypto address
   * which will be used to pay the order. In some cases, this is optional.
   * See "Estimate the amount of an order" to figure out if this information
   * can be omitted or not. Omitting the information increases the number of
   * situations were we can be required to cancel an order uppon
   * reception of the funds. To ensure a reliable execution of your order,
   * the crypto address or IBAN must be provided and the paiment must be
   * made from the provided object.
   */
  place_order: {
    responses: {
      /**
       * The order has been successfully created.
       *
       * The `Location` header contains the URI (which can be relative) at
       * which the order status and details can be retrieved. That is the
       * `Location` header is meant to be interpreted as per RFC 7231 section
       * 7.1.2.
       */
      201: unknown;
      /**
       * Following cases:
       *
       * - Unsupported currency pair.
       * - Quota exceeded for the bank account or crypto-address.
       * - Internal error.
       */
      400: unknown;
      429: components['responses']['RateLimited'];
    };
    requestBody: {
      content: {
        'application/json': {
          client_value?: components['schemas']['ClientValue'];
          /** @description Information of a contact person to be used in case something unforeseen happens with the order. This information is optional. The customer can always get in touch with support via the order status page. */
          contact_person?: {
            email?: string;
          };
          input: components['schemas']['OrderInputOutput'];
          output: components['schemas']['OrderInputOutput'];
          partner_fee?: components['schemas']['PartnerFee'];
        };
      };
    };
  };
  /**
   * The endpoint is similar to the endpoints allowing an order to be placed.
   * However, only the currencies and the input or output amount are
   * specified in the request.
   *
   * ### Estimate the output amount corresponding to an input amount
   *
   * To estimate the output amount simply place the `amount` in the `input`.
   *
   * ### Estimate the input amount corresponding to an output amount
   *
   * To estimate the input amount simply place the `amount` in the `output`.
   */
  estimate_order_amount: {
    responses: {
      /** Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['AmountEstimation'];
        };
      };
      /** Malformed request. <br> Invalid currency code. <br> Invalid currency pair. <br> Invalid amount. */
      400: unknown;
      429: components['responses']['RateLimited'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AmountEstimationRequest'];
      };
    };
  };
  /** This endpoint is equivalent to `/orders/estimate` except that several estimations can be performed in a single request. */
  estimate_order_amount_multiple: {
    responses: {
      /** Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['AmountEstimation'][];
        };
      };
      /** This endpoint can produce the same errors as `/orders/estimate` in addition to refusing to perform too many estimations in a single call. */
      400: unknown;
      429: components['responses']['RateLimited'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AmountEstimationRequest'][];
      };
    };
  };
  /**
   * Please note the following:
   *
   * - If the amount paid is not exactly the input amount, we can be
   *   required to cancel the order, or the output amount will be adjusted
   *   and extra fees could be charged.
   * - If it is sent in multiple transactions, we can be required to cancel
   *   the order and extra processing fees could be charged.
   *
   * ### Minimal details
   *
   * When the request does not include sufficient credentials, only minimal
   * information is returned. If you are unexpectedly receiving only minimal
   * details, please double check which security scheme you are using and
   * used to place the order. When no security scheme is used, please make
   * sure you are making all the requests to the correct URLs and that
   * cookies are accepted and handled according to RFC 6265. Most user
   * agents handle that for you but cookies must not be disabled and you may
   * have to request the user-agent to include credentials in the request.
   *
   * The full information is returned when one of the following is true:
   *
   * - No security scheme is used and the order was placed while
   *   unauthenticated, in the same session.
   * - The `bity_account_oauth` or `bity_account_oauth_client` security
   *   scheme are used, the scope includes
   *   `https://auth.bity.com/scopes/exchange.place` or
   *   `https://auth.bity.com/scopes/exchange.history`, and the OAuth client
   *   is the client having placed the order.
   * - The `bity_account_oauth` or `bity_account_oauth_client` security
   *   scheme are used and the scope includes
   *   `https://auth.bity.com/scopes/exchange.audit`.
   * - The `client_oauth` security scheme is used and the OAuth client is
   *   the client having placed the order.
   *
   * ### Output address signature
   *
   * When the customer is not authenticated or has not gone through the KYC
   * process, crypto-to-crypto and fiat-to-crypto orders require the
   * signature of a message by the output address for the order to become
   * executable. When such a signature is required "message_to_sign" is
   * included in the response. The price will not be fixed and the payment
   * details will not be provided before the signature of the message is
   * submitted.
   *
   * ### Input and output objects
   *
   * The input type and output type can be one of "crypto_address" or
   * "bank_account".
   *
   * - In case it is "crypto_address" the object additionally contains
   *   "crypto_address".
   * - In case it is "bank_account" the object additionally contains "iban".
   *
   * Whenever the input object contains iban or crypto_address, the input
   * must be paid from the corresponding object. If this is not the case, we
   * can be required to cancel the order and perform a refund uppon
   * reception of the funds and extra fees can be charged.
   *
   * ### Payment details
   *
   * This object describes how to pay the input amount.
   *
   * There are two different possible types of payment details:
   * `"crypto_address"` and `"bank_account"`. Both types are described
   * bellow. The amount and the associated currency is found in the input
   * object.
   *
   * #### Crypto address
   *
   * When the payment must be made to a crypto address, the `type` is
   * `"crypto_address"` and the address to use as a destination address
   * is found in the `"crypto_address"` attribute.
   *
   * #### Bank account
   *
   * When the payment must be made to a bank account, the type is
   * `"bank_account"`.
   *
   * In most cases the banks involved in sending, transmitting and receiving
   * the payment will require the IBAN, SWIFT code and the bank account
   * owner name and address to process the payment. This is reflected by the
   * information provided in the response:
   *
   * - `"iban"`: The IBAN to which the payment must be made.
   * - `"owner"`: An object containing information about the owner of the
   *   bank account. It can contain the following properties: "name",
   *   "address", "address_complement", "zip", "city", "state", "country".
   *   The country is formatted as a two-letter country code.
   * - `"swift_bic"` The SWIFT code (also known as BIC) of the bank account
   *   at which the bank account is located.
   *
   * ### Amounts
   *
   * When `timestamp_price_guaranteed` is not present or has elapsed, the
   * amounts (input, output and price breakdown) are an estimation of the
   * amounts that would have been used should the order have been executed
   * at the time the order details were retrieved.
   *
   * When `timestamp_price_guaranteed` is present and has not elapsed, the
   * amounts correspond to the amounts that will be used provided that the
   * exact input amount is received before `timestamp_price_guaranteed`
   * elapses.
   */
  get_order_details: {
    parameters: {
      path: {
        /** ID of the order. */
        order_uuid: string;
      };
    };
    responses: {
      /** Order successfully retrieved. */
      200: {
        content: {
          'application/json': Partial<components['schemas']['Order']> &
            Partial<components['schemas']['OrderMinimal']>;
        };
      };
      /** Order with such ID not found. */
      400: unknown;
      429: components['responses']['RateLimited'];
    };
  };
  /**
   * Attempt to cancel an order.
   *
   * If a payment is received after the order has been cancelled, Bity is
   * free to choose what to do at its own discretion. Bity will generally
   * attempt to perform a refund to the same crypto-address or IBAN having
   * performed the payment. Various unpredictable fees may apply. It is very
   * highly recommended to not cancel orders for which a payment has already
   * been sent.
   *
   * This functionality is meant for the customer to cancel orders for which
   * no payment has been made and will be made. In particular, it is not
   * meant to cancel orders for which a payment has already been made or
   * will be made at a later time, and will result in an unpredictable
   * outcome if used in such situation.
   */
  cancel_order: {
    parameters: {
      path: {
        /** Identifier of the order to attempt to cancel */
        order_uuid: string;
      };
    };
    responses: {
      /**
       * The request to cancel the order is being processed asynchronously.
       *
       * It is at this time not possible to know whether the cancellation
       * attempt will be successful or not.
       */
      202: unknown;
      /** The cancellation attempt was successful. */
      204: never;
      /** The cancellation attempt was unsuccessful. */
      400: unknown;
      429: components['responses']['RateLimited'];
    };
  };
  /**
   * This endpoint places a new order with the same amount, same input
   * object, same ouput object and same payment details as an already
   * executed one.
   *
   * It is only possible to duplicate orders of which the full order details
   * are accessible.
   */
  duplicate_order: {
    parameters: {
      path: {
        /** ID of the order to duplicate. */
        order_uuid: string;
      };
    };
    responses: {
      /**
       * The order has been successfully created.
       *
       * The `Location` header contains the URI (which can be relative) at
       * which the order status and details can be retrieved. That is, the
       * `Location` header is meant to be interpreted as per RFC 7231
       * section 7.1.2.
       */
      201: unknown;
      /** This operation can return the same errors as the `place_order` operation (POST /orders). */
      400: unknown;
      429: components['responses']['RateLimited'];
    };
  };
  /**
   * Submit the signature of the message provided in the order details.
   *
   * The body of the request must contain the signature of the message.
   * The message to sign is located in the `body` property of the
   * `message_to_sign` object of the order details.
   *
   * Once the signature is verified to be correct (204 response), the
   * order becomes executable and the order details will contain the
   * `payment_details` object which provides the information to use to pay
   * the order.
   *
   * Do not build the URL of this endpoint but instead use the value of
   * `signature_submission_url` included along the message to be signed in
   * the order details.
   */
  sign_proof_of_ownership_message: {
    parameters: {
      path: {
        /** ID of the order. */
        order_uuid: string;
      };
    };
    responses: {
      /** The signature is correct, the order details now contain `payment_details`. */
      204: never;
      /** The signature is invalid. */
      400: unknown;
      /** The associated order could not be found or there is no message to sign. */
      404: unknown;
      429: components['responses']['RateLimited'];
      /** Internal error. */
      502: unknown;
      /** Internal error. */
      503: unknown;
      /** Internal error. */
      504: unknown;
    };
    requestBody: {
      content: {
        '*/*': string;
        'text/plain': string;
      };
    };
  };
  /** Gets a list of all the currency pairs that can be traded through the Bity platform. */
  list_currency_pairs: {
    parameters: {
      query: {
        /** Retrieve all pairs for given input currency code. This parameter can be repeated several times to match many input currencies. */
        input?: string;
        /** Retrieve all pairs for given output currency code. This parameter can be repeated several times to match many output currencies. */
        output?: string;
        /** Retrieve all pairs that are enabled for trading or not. */
        enabled?: string;
      };
    };
    responses: {
      /** Successful operation */
      200: {
        content: {
          'application/json': {
            pairs: components['schemas']['CurrencyPair'][];
          };
        };
      };
      429: components['responses']['RateLimited'];
    };
  };
}

export interface external {}
